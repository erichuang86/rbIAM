{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 When using Amazon Elastic Kubernetes Service ( EKS ) you will at some point ask yourself: how does AWS Identity and Access Management ( IAM ) and Kubernetes Role-based access control ( RBAC ) play together. Do they overlap? Are they complementary? Are there dependencies. rbIAM aims to help you navigate this space. If you want to learn more about the Why then read on and/or check out the terminology , otherwise check out the getting started guide now. Motivation \u00b6 Let's have a look at a concrete example, for motivation. Take the Fluent Bit output plugin for Amazon Kinesis Data Firehose . In Centralized Container Logging with Fluent Bit we described how to use it. The setup, in a nutshell, is as follows: The Fluent Bit is deployed as a DaemonSet as per eks-fluent-bit-daemonset.yaml and: depends on an IAM policy, defined in eks-fluent-bit-daemonset-policy.json , giving it the permissions to write to the Kinesis Data Firehose, manage log streams in CloudWatch, etc., as well as a Kubernetes role, defined in eks-fluent-bit-daemonset-rbac.yaml , giving it the permissions to list and query pods and namespaces, in the cluster, so that it can receive the logs from the containers. Use cases \u00b6 TBD","title":"Overview"},{"location":"#overview","text":"When using Amazon Elastic Kubernetes Service ( EKS ) you will at some point ask yourself: how does AWS Identity and Access Management ( IAM ) and Kubernetes Role-based access control ( RBAC ) play together. Do they overlap? Are they complementary? Are there dependencies. rbIAM aims to help you navigate this space. If you want to learn more about the Why then read on and/or check out the terminology , otherwise check out the getting started guide now.","title":"Overview"},{"location":"#motivation","text":"Let's have a look at a concrete example, for motivation. Take the Fluent Bit output plugin for Amazon Kinesis Data Firehose . In Centralized Container Logging with Fluent Bit we described how to use it. The setup, in a nutshell, is as follows: The Fluent Bit is deployed as a DaemonSet as per eks-fluent-bit-daemonset.yaml and: depends on an IAM policy, defined in eks-fluent-bit-daemonset-policy.json , giving it the permissions to write to the Kinesis Data Firehose, manage log streams in CloudWatch, etc., as well as a Kubernetes role, defined in eks-fluent-bit-daemonset-rbac.yaml , giving it the permissions to list and query pods and namespaces, in the cluster, so that it can receive the logs from the containers.","title":"Motivation"},{"location":"#use-cases","text":"TBD","title":"Use cases"},{"location":"getting-started/","text":"Getting Started \u00b6","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"terminology/","text":"Terminology \u00b6 In the following we define the terms used in AWS IAM and Kubernetes RBAC, along with the motivational example , to illustrate what exactly each term means. AWS Identity and Access Management (IAM) \u00b6 Conceptually, AWS IAM looks as follows: the access an identity\u2014such as a user or role\u2014has concerning an AWS service or resource is determined through the attached policies that list allowed actions on resources. More formally, we're using the following terms: Principal An identity in AWS able to carry out an action offered by an AWS service (like listing EC2 instances) or able access a resource (such as reading from an S3 bucket). The identity can be an account root user , an IAM user , or a role . Role An identity that\u2014in contrast to an IAM user/root user, which are uniquely associated with a person\u2014is intended to be assumable by someone (person) or something (service). A role doesn't have long-term credentials, but rather, when assuming a role, temporary security credentials are provided, for the duration of a session. Policy A JSON document using the IAM policy language that either: defines allowed actions on resources (services) a role can use (permissions policy), or defines who is allowed to assume a role , in which case the trusted entity is included in the policy as the principal (trust policy). For example, for our Fluent Bit output plugin deployed as a DaemonSet in EKS, one of the IAM regimes looks as follows (compare: IAM policy used ): In a nutshell: the Fluent Bit output plugin, running in a container part of a pod that is running on an EC2 instance part of a node group with a role eksctl-fluent-bit-demo-nodegroup-ng-2fb6f1a-NodeInstanceRole-P6QXJ5EYS6 is permitted to perform the PutRecordBatch action in Firehose; in fact, with said policy, the Fluent Bit plugin is allowed to put records into any delivery stream, since the resource has not been limited to a specific one. Kubernetes Role-based Access Control (RBAC) \u00b6 Conceptually, Kubernetes RBAC looks as follows: the access an entity\u2014such as a user or service account\u2014has concerning a Kubernetes resource is determined through two indirections: roles (which define access rules) and role bindings (attaching or binding a role to an entity). More formally, we're using the following terms: Entity A user, group, or a Kubernetes service account . User A human being that is using Kubernetes, either via CLI tools such as kubectl , using the HTTP API of the API server, or indirectly, via cloud native apps. Service account Represents processes running in pods that wish to interact with the API server; a namespaced Kubernetes resource, representing the identity of an app. Resource A Kubernetes abstraction, representing operational aspects. Can be namespaced, for example a pod (co-scheduled containers), a service (east-west load balancer), or a deployment (pod supervisor for app life cycle management) or cluster-wide, such as nodes or namespaces themselves. Role Defines a set of strictly additive rules, representing a set of permissions. These permissions define what actions an entity is allowed to carry out with respect to a set of resources. Can be namespaced (then the role is only valid in the context of said namespace) or cluster wide. Role binding Grants the permissions defined in a role to an entity . Can be namespaced (then the binding is only valid in the context of said namespace or cluster wide. Note that it is perfectly possible and even desirable to define a cluster-wide role and then used a (namespaced) role binding. This allows straight-forward re-use of roles across namespaces. For example, for our Fluent Bit output plugin deployed as a DaemonSet in EKS, the RBAC regime looks as follows (compare: role & role binding used ): In a nutshell: the Fluent Bit output plugin, using the default:fluent-bit service account, is permitted to read and list pods in the default namespace.","title":"Terminology"},{"location":"terminology/#terminology","text":"In the following we define the terms used in AWS IAM and Kubernetes RBAC, along with the motivational example , to illustrate what exactly each term means.","title":"Terminology"},{"location":"terminology/#markdown","text":"Conceptually, AWS IAM looks as follows: the access an identity\u2014such as a user or role\u2014has concerning an AWS service or resource is determined through the attached policies that list allowed actions on resources. More formally, we're using the following terms: Principal An identity in AWS able to carry out an action offered by an AWS service (like listing EC2 instances) or able access a resource (such as reading from an S3 bucket). The identity can be an account root user , an IAM user , or a role . Role An identity that\u2014in contrast to an IAM user/root user, which are uniquely associated with a person\u2014is intended to be assumable by someone (person) or something (service). A role doesn't have long-term credentials, but rather, when assuming a role, temporary security credentials are provided, for the duration of a session. Policy A JSON document using the IAM policy language that either: defines allowed actions on resources (services) a role can use (permissions policy), or defines who is allowed to assume a role , in which case the trusted entity is included in the policy as the principal (trust policy). For example, for our Fluent Bit output plugin deployed as a DaemonSet in EKS, one of the IAM regimes looks as follows (compare: IAM policy used ): In a nutshell: the Fluent Bit output plugin, running in a container part of a pod that is running on an EC2 instance part of a node group with a role eksctl-fluent-bit-demo-nodegroup-ng-2fb6f1a-NodeInstanceRole-P6QXJ5EYS6 is permitted to perform the PutRecordBatch action in Firehose; in fact, with said policy, the Fluent Bit plugin is allowed to put records into any delivery stream, since the resource has not been limited to a specific one.","title":"IAM"},{"location":"terminology/#markdown","text":"Conceptually, Kubernetes RBAC looks as follows: the access an entity\u2014such as a user or service account\u2014has concerning a Kubernetes resource is determined through two indirections: roles (which define access rules) and role bindings (attaching or binding a role to an entity). More formally, we're using the following terms: Entity A user, group, or a Kubernetes service account . User A human being that is using Kubernetes, either via CLI tools such as kubectl , using the HTTP API of the API server, or indirectly, via cloud native apps. Service account Represents processes running in pods that wish to interact with the API server; a namespaced Kubernetes resource, representing the identity of an app. Resource A Kubernetes abstraction, representing operational aspects. Can be namespaced, for example a pod (co-scheduled containers), a service (east-west load balancer), or a deployment (pod supervisor for app life cycle management) or cluster-wide, such as nodes or namespaces themselves. Role Defines a set of strictly additive rules, representing a set of permissions. These permissions define what actions an entity is allowed to carry out with respect to a set of resources. Can be namespaced (then the role is only valid in the context of said namespace) or cluster wide. Role binding Grants the permissions defined in a role to an entity . Can be namespaced (then the binding is only valid in the context of said namespace or cluster wide. Note that it is perfectly possible and even desirable to define a cluster-wide role and then used a (namespaced) role binding. This allows straight-forward re-use of roles across namespaces. For example, for our Fluent Bit output plugin deployed as a DaemonSet in EKS, the RBAC regime looks as follows (compare: role & role binding used ): In a nutshell: the Fluent Bit output plugin, using the default:fluent-bit service account, is permitted to read and list pods in the default namespace.","title":"IAM"}]}