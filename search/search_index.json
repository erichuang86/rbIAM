{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 When using Amazon Elastic Kubernetes Service ( EKS ) you will at some point ask yourself: how does AWS Identity and Access Management ( IAM ) and Kubernetes Role-based access control ( RBAC ) play together. Do they overlap? Are they complementary? Are there dependencies. rbIAM aims to help you navigate this space. If you want to learn more about the Why then read on and/or check out the terminology , otherwise check out the getting started guide now. Motivation \u00b6 Let's have a look at a concrete example, for motivation. Take the Fluent Bit output plugin for Amazon Kinesis Data Firehose . In Centralized Container Logging with Fluent Bit we described how to use it. The setup, in a nutshell, is as follows: The Fluent Bit is deployed as a DaemonSet as per eks-fluent-bit-daemonset.yaml and: depends on an IAM policy, defined in eks-fluent-bit-daemonset-policy.json , giving it the permissions to write to the Kinesis Data Firehose, manage log streams in CloudWatch, etc., as well as a Kubernetes role, defined in eks-fluent-bit-daemonset-rbac.yaml , giving it the permissions to list and query pods and namespaces, in the cluster, so that it can receive the logs from the containers. Use cases \u00b6 TBD","title":"Overview"},{"location":"#overview","text":"When using Amazon Elastic Kubernetes Service ( EKS ) you will at some point ask yourself: how does AWS Identity and Access Management ( IAM ) and Kubernetes Role-based access control ( RBAC ) play together. Do they overlap? Are they complementary? Are there dependencies. rbIAM aims to help you navigate this space. If you want to learn more about the Why then read on and/or check out the terminology , otherwise check out the getting started guide now.","title":"Overview"},{"location":"#motivation","text":"Let's have a look at a concrete example, for motivation. Take the Fluent Bit output plugin for Amazon Kinesis Data Firehose . In Centralized Container Logging with Fluent Bit we described how to use it. The setup, in a nutshell, is as follows: The Fluent Bit is deployed as a DaemonSet as per eks-fluent-bit-daemonset.yaml and: depends on an IAM policy, defined in eks-fluent-bit-daemonset-policy.json , giving it the permissions to write to the Kinesis Data Firehose, manage log streams in CloudWatch, etc., as well as a Kubernetes role, defined in eks-fluent-bit-daemonset-rbac.yaml , giving it the permissions to list and query pods and namespaces, in the cluster, so that it can receive the logs from the containers.","title":"Motivation"},{"location":"#use-cases","text":"TBD","title":"Use cases"},{"location":"getting-started/","text":"Getting Started \u00b6","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"terminology/","text":"Terminology \u00b6 AWS Identity and Access Management (IAM) \u00b6 Conceptually, AWS IAM looks as follows: TBD Principal An entity in AWS able to carry out an action and/or access a resource. The entity can be an account root user , an IAM user , or a role . Role An entity that, in contrast to an IAM user or root user which are uniquely associated with a person, is intended to be assumable by someone. A role does not have long-term credentials, but rather, when assuming a role, it provides you with temporary security credentials for the duration of a session. Policy A JSON document using the IAM policy language that either defines actions and resources a role can use (permissions policy) or define who is allowed to assume a role , in which case the trusted entity is included in the policy as the principal (trust policy). For example, for our Fluent Bit output plugin deployed as a DaemonSet , the RBAC regime looks as follows: TBD Kubernetesd Role-based Access Control (RBAC) \u00b6 Conceptually, Kubernetes RBAC looks as follows: The access an entity has concerning a resource is determined through two indirections: roles (define access rules) and role binding (attach or bind a role to an entity). More formally: Entity A user, group, or a Kubernetes service account . User A human being that is using Kubernetes, either via CLI tools such as kubectl , using the HTTP API of the API server, or indirectly, via cloud native apps. Service account Represents processes running in pods that wish to interact with the API server; a namespaced Kubernetes resource, representing the identity of an app. Resource A Kubernetes abstraction, representing operational aspects. Can be namespaced, for example a pod (co-scheduled containers), a service (east-west load balancer), or a deployment (pod supervisor for app life cycle management) or cluster-wide, such as nodes or namespaces themselves. Role Defines a set of strictly additive rules, representing a set of permissions. These permissions define what actions an entity is allowed to carry out with respect to a set of resources. Can be namespaced (then the role is only valid in the context of said namespace) or cluster wide. Role binding Grants the permissions defined in a role to an entity . Can be namespaced (then the binding is only valid in the context of said namespace or cluster wide. Note that it is perfectly possible and even desirable to define a cluster-wide role and then used a (namespaced) role binding. This allows straight-forward re-use of roles across namespaces. For example, for our Fluent Bit output plugin deployed as a DaemonSet , the RBAC regime looks as follows: In a nutshell: the Fluent Bit output plugin, using the default:fluent-bit service account, is permitted to read and list pods in the default namespace.","title":"Terminology"},{"location":"terminology/#terminology","text":"","title":"Terminology"},{"location":"terminology/#markdown","text":"Conceptually, AWS IAM looks as follows: TBD Principal An entity in AWS able to carry out an action and/or access a resource. The entity can be an account root user , an IAM user , or a role . Role An entity that, in contrast to an IAM user or root user which are uniquely associated with a person, is intended to be assumable by someone. A role does not have long-term credentials, but rather, when assuming a role, it provides you with temporary security credentials for the duration of a session. Policy A JSON document using the IAM policy language that either defines actions and resources a role can use (permissions policy) or define who is allowed to assume a role , in which case the trusted entity is included in the policy as the principal (trust policy). For example, for our Fluent Bit output plugin deployed as a DaemonSet , the RBAC regime looks as follows: TBD","title":"IAM"},{"location":"terminology/#markdown","text":"Conceptually, Kubernetes RBAC looks as follows: The access an entity has concerning a resource is determined through two indirections: roles (define access rules) and role binding (attach or bind a role to an entity). More formally: Entity A user, group, or a Kubernetes service account . User A human being that is using Kubernetes, either via CLI tools such as kubectl , using the HTTP API of the API server, or indirectly, via cloud native apps. Service account Represents processes running in pods that wish to interact with the API server; a namespaced Kubernetes resource, representing the identity of an app. Resource A Kubernetes abstraction, representing operational aspects. Can be namespaced, for example a pod (co-scheduled containers), a service (east-west load balancer), or a deployment (pod supervisor for app life cycle management) or cluster-wide, such as nodes or namespaces themselves. Role Defines a set of strictly additive rules, representing a set of permissions. These permissions define what actions an entity is allowed to carry out with respect to a set of resources. Can be namespaced (then the role is only valid in the context of said namespace) or cluster wide. Role binding Grants the permissions defined in a role to an entity . Can be namespaced (then the binding is only valid in the context of said namespace or cluster wide. Note that it is perfectly possible and even desirable to define a cluster-wide role and then used a (namespaced) role binding. This allows straight-forward re-use of roles across namespaces. For example, for our Fluent Bit output plugin deployed as a DaemonSet , the RBAC regime looks as follows: In a nutshell: the Fluent Bit output plugin, using the default:fluent-bit service account, is permitted to read and list pods in the default namespace.","title":"IAM"}]}